// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * EventGraph API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type {Configuration} from './configuration';
import type {AxiosPromise, AxiosInstance, RawAxiosRequestConfig} from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
import type {RequestArgs} from './base';
// @ts-ignore
import {BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap} from './base';

/**
 *
 * @export
 * @interface AddServiceToGraphPost400Response
 */
export interface AddServiceToGraphPost400Response {
  /**
   *
   * @type {Array<AddServiceToGraphPost400ResponseErrorsInner>}
   * @memberof AddServiceToGraphPost400Response
   */
  errors?: Array<AddServiceToGraphPost400ResponseErrorsInner>;
}
/**
 *
 * @export
 * @interface AddServiceToGraphPost400ResponseErrorsInner
 */
export interface AddServiceToGraphPost400ResponseErrorsInner {
  /**
   * Message code
   * @type {number}
   * @memberof AddServiceToGraphPost400ResponseErrorsInner
   */
  code?: number;
  /**
   * Response message
   * @type {string}
   * @memberof AddServiceToGraphPost400ResponseErrorsInner
   */
  message?: string;
  /**
   * Indicates failure due to client error
   * @type {string}
   * @memberof AddServiceToGraphPost400ResponseErrorsInner
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof AddServiceToGraphPost400ResponseErrorsInner
   */
  fileName?: string;
  /**
   *
   * @type {string}
   * @memberof AddServiceToGraphPost400ResponseErrorsInner
   */
  errorMessage?: string;
}
/**
 *
 * @export
 * @interface BaseResponse
 */
export interface BaseResponse {
  /**
   * Message code
   * @type {number}
   * @memberof BaseResponse
   */
  code?: number;
  /**
   * Response message
   * @type {string}
   * @memberof BaseResponse
   */
  message?: string;
  /**
   * Indicates failure due to client error
   * @type {string}
   * @memberof BaseResponse
   */
  status?: string;
}
/**
 *
 * @export
 * @interface CalculateAllPathsPost200Response
 */
export interface CalculateAllPathsPost200Response {
  /**
   * Message code
   * @type {number}
   * @memberof CalculateAllPathsPost200Response
   */
  code?: number;
  /**
   * Response message
   * @type {string}
   * @memberof CalculateAllPathsPost200Response
   */
  message?: string;
  /**
   * Indicates failure due to client error
   * @type {string}
   * @memberof CalculateAllPathsPost200Response
   */
  status?: string;
  /**
   * List of all paths (each path is a list of links)
   * @type {Array<Array<LinkDTO>>}
   * @memberof CalculateAllPathsPost200Response
   */
  paths?: Array<Array<LinkDTO>>;
  /**
   * All unique tags found in the paths
   * @type {Array<string>}
   * @memberof CalculateAllPathsPost200Response
   */
  uniqueTags?: Array<string>;
}
/**
 *
 * @export
 * @interface CalculateAllPathsPostRequest
 */
export interface CalculateAllPathsPostRequest {
  /**
   *
   * @type {EventGraphDTO}
   * @memberof CalculateAllPathsPostRequest
   */
  eventGraph: EventGraphDTO;
  /**
   * Starting node UUID
   * @type {string}
   * @memberof CalculateAllPathsPostRequest
   */
  from: string;
  /**
   * Destination node UUID
   * @type {string}
   * @memberof CalculateAllPathsPostRequest
   */
  to: string;
}
/**
 * Error message for a file upload or EventGraph validation.
 * @export
 * @interface ErrorDTO
 */
export interface ErrorDTO {
  /**
   *
   * @type {string}
   * @memberof ErrorDTO
   */
  fileName: string;
  /**
   *
   * @type {string}
   * @memberof ErrorDTO
   */
  errorMessage: string;
}
/**
 *
 * @export
 * @interface EventDTO
 */
export interface EventDTO {
  /**
   * Unique identifier for the event.
   * @type {string}
   * @memberof EventDTO
   */
  id: string;
  /**
   *
   * @type {string}
   * @memberof EventDTO
   */
  schema: string;
  /**
   *
   * @type {string}
   * @memberof EventDTO
   */
  name: string;
  /**
   *
   * @type {Array<string>}
   * @memberof EventDTO
   */
  tags?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof EventDTO
   */
  eventType?: string;
  /**
   *
   * @type {string}
   * @memberof EventDTO
   */
  eventDescription?: string;
}
/**
 *
 * @export
 * @interface EventGraphDTO
 */
export interface EventGraphDTO {
  /**
   * Name of the EventGraph.
   * @type {string}
   * @memberof EventGraphDTO
   */
  name?: string;
  /**
   * List of nodes in the EventGraph.
   * @type {Array<NodeDTO>}
   * @memberof EventGraphDTO
   */
  nodes?: Array<NodeDTO>;
  /**
   * List of nodes in the EventGraph.
   * @type {Array<EventDTO>}
   * @memberof EventGraphDTO
   */
  events?: Array<EventDTO>;
  /**
   * List of links in the EventGraph.
   * @type {Array<LinkDTO>}
   * @memberof EventGraphDTO
   */
  links?: Array<LinkDTO>;
  /**
   *
   * @type {Array<ErrorDTO>}
   * @memberof EventGraphDTO
   */
  errors?: Array<ErrorDTO>;
  /**
   *
   * @type {Array<string>}
   * @memberof EventGraphDTO
   */
  tags?: Array<string>;
}
/**
 *
 * @export
 * @interface GenerateAllServicePdfPost400Response
 */
export interface GenerateAllServicePdfPost400Response {
  /**
   *
   * @type {string}
   * @memberof GenerateAllServicePdfPost400Response
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof GenerateAllServicePdfPost400Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface GenerateAllServicePdfPost500Response
 */
export interface GenerateAllServicePdfPost500Response {
  /**
   *
   * @type {string}
   * @memberof GenerateAllServicePdfPost500Response
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof GenerateAllServicePdfPost500Response
   */
  message?: string;
}
/**
 *
 * @export
 * @interface GenerateDocxPost200Response
 */
export interface GenerateDocxPost200Response {
  /**
   * Message code
   * @type {number}
   * @memberof GenerateDocxPost200Response
   */
  code?: number;
  /**
   * Response message
   * @type {string}
   * @memberof GenerateDocxPost200Response
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof GenerateDocxPost200Response
   */
  status?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof GenerateDocxPost200Response
   */
  downloadLinks?: {[key: string]: string};
}
/**
 *
 * @export
 * @interface GenerateJsonExamplePost200Response
 */
export interface GenerateJsonExamplePost200Response {
  /**
   * Message code
   * @type {number}
   * @memberof GenerateJsonExamplePost200Response
   */
  code?: number;
  /**
   * The generated JSON example as a string.
   * @type {string}
   * @memberof GenerateJsonExamplePost200Response
   */
  jsonExample?: string;
}
/**
 *
 * @export
 * @interface GenerateJsonExamplePostRequest
 */
export interface GenerateJsonExamplePostRequest {
  /**
   * The JSON schema as a string.
   * @type {string}
   * @memberof GenerateJsonExamplePostRequest
   */
  jsonSchema: string;
}
/**
 *
 * @export
 * @interface GenerateJsonSchemaPost200Response
 */
export interface GenerateJsonSchemaPost200Response {
  /**
   * The generated JSON schema as a string.
   * @type {string}
   * @memberof GenerateJsonSchemaPost200Response
   */
  schema?: string;
  /**
   * Message code
   * @type {number}
   * @memberof GenerateJsonSchemaPost200Response
   */
  code?: number;
}
/**
 *
 * @export
 * @interface GenerateJsonSchemaPostRequest
 */
export interface GenerateJsonSchemaPostRequest {
  /**
   * The JSON input as a string.
   * @type {string}
   * @memberof GenerateJsonSchemaPostRequest
   */
  jsonInput: string;
}
/**
 *
 * @export
 * @interface GenerateMarkdownPost200Response
 */
export interface GenerateMarkdownPost200Response {
  /**
   * Message code
   * @type {number}
   * @memberof GenerateMarkdownPost200Response
   */
  code?: number;
  /**
   * Response message
   * @type {string}
   * @memberof GenerateMarkdownPost200Response
   */
  message?: string;
  /**
   * Indicates failure due to client error
   * @type {string}
   * @memberof GenerateMarkdownPost200Response
   */
  status?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof GenerateMarkdownPost200Response
   */
  downloadLinks?: {[key: string]: string};
}
/**
 *
 * @export
 * @interface GeneratePdfPost200Response
 */
export interface GeneratePdfPost200Response {
  /**
   * Message code
   * @type {number}
   * @memberof GeneratePdfPost200Response
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof GeneratePdfPost200Response
   */
  message?: string;
  /**
   *
   * @type {string}
   * @memberof GeneratePdfPost200Response
   */
  status?: string;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof GeneratePdfPost200Response
   */
  downloadLinks?: {[key: string]: string};
}
/**
 *
 * @export
 * @interface GenerateSpecPost200Response
 */
export interface GenerateSpecPost200Response {
  /**
   * Message code
   * @type {number}
   * @memberof GenerateSpecPost200Response
   */
  code?: number;
  /**
   * Response message
   * @type {string}
   * @memberof GenerateSpecPost200Response
   */
  message?: string;
  /**
   * Indicates failure due to client error
   * @type {string}
   * @memberof GenerateSpecPost200Response
   */
  status?: string;
  /**
   * Links to the generated specification files
   * @type {{ [key: string]: string; }}
   * @memberof GenerateSpecPost200Response
   */
  downloadLinks?: {[key: string]: string};
}
/**
 *
 * @export
 * @interface GetServiceSpecificationPost200Response
 */
export interface GetServiceSpecificationPost200Response {
  /**
   * Message code
   * @type {number}
   * @memberof GetServiceSpecificationPost200Response
   */
  code?: number;
  /**
   * Response message
   * @type {string}
   * @memberof GetServiceSpecificationPost200Response
   */
  message?: string;
  /**
   * Indicates failure due to client error
   * @type {string}
   * @memberof GetServiceSpecificationPost200Response
   */
  status?: string;
  /**
   * UUID of the service node
   * @type {string}
   * @memberof GetServiceSpecificationPost200Response
   */
  serviceNodeId?: string;
  /**
   * OpenAPI specification as a string
   * @type {string}
   * @memberof GetServiceSpecificationPost200Response
   */
  specification?: string;
}
/**
 *
 * @export
 * @interface GetServiceSpecificationPostRequest
 */
export interface GetServiceSpecificationPostRequest {
  /**
   * UUID of the service node
   * @type {string}
   * @memberof GetServiceSpecificationPostRequest
   */
  serviceNodeId: string;
  /**
   *
   * @type {EventGraphDTO}
   * @memberof GetServiceSpecificationPostRequest
   */
  eventGraph: EventGraphDTO;
}
/**
 * Link between two nodes in the EventGraph.
 * @export
 * @interface LinkDTO
 */
export interface LinkDTO {
  /**
   *
   * @type {string}
   * @memberof LinkDTO
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof LinkDTO
   */
  fromId: string;
  /**
   *
   * @type {string}
   * @memberof LinkDTO
   */
  toId: string;
  /**
   *
   * @type {string}
   * @memberof LinkDTO
   */
  group?: string;
  /**
   *
   * @type {string}
   * @memberof LinkDTO
   */
  eventId: string;
  /**
   *
   * @type {Array<string>}
   * @memberof LinkDTO
   */
  tags?: Array<string>;
}
/**
 *
 * @export
 * @interface MDResponse
 */
export interface MDResponse {
  /**
   *
   * @type {string}
   * @memberof MDResponse
   */
  mdString?: string;
}
/**
 *
 * @export
 * @interface NodeDTO
 */
export interface NodeDTO {
  /**
   * Unique identifier for the node.
   * @type {string}
   * @memberof NodeDTO
   */
  id?: string;
  /**
   * Description of node
   * @type {string}
   * @memberof NodeDTO
   */
  nodeDescription?: string;
  /**
   * URL og HTTP node(only for HTTP nodes)
   * @type {string}
   * @memberof NodeDTO
   */
  nodeUrl?: string;
  /**
   * List of nodes(services) - ids - to which the node belongs.
   * @type {Array<string>}
   * @memberof NodeDTO
   */
  belongsToGraph: Array<string>;
  /**
   *
   * @type {string}
   * @memberof NodeDTO
   */
  name: string;
  /**
   * Type of the node. SERVICE or TOPIC. not NULL
   * @type {string}
   * @memberof NodeDTO
   */
  type: NodeDTOTypeEnum;
  /**
   * Broker type for the node. null if: no broker type is specified or node is SERVICE. Kafka, JMS, RabbitMQ are supported.
   * @type {string}
   * @memberof NodeDTO
   */
  brokerType?: NodeDTOBrokerTypeEnum;
  /**
   * Schema of request body
   * @type {string}
   * @memberof NodeDTO
   */
  requestBody?: string;
  /**
   * Schema of response body
   * @type {string}
   * @memberof NodeDTO
   */
  responseBody?: string;
  /**
   * http method type
   * @type {string}
   * @memberof NodeDTO
   */
  methodType?: NodeDTOMethodTypeEnum;
  /**
   *
   * @type {Array<string>}
   * @memberof NodeDTO
   */
  tags?: Array<string>;
  /**
   * List of documentation files related to this node (service, topic, http).
   * @type {Array<string>}
   * @memberof NodeDTO
   */
  documentationFileLinks?: Array<string>;
}

export const NodeDTOTypeEnum = {
  Service: 'SERVICE',
  Topic: 'TOPIC',
  Http: 'HTTP',
} as const;

export type NodeDTOTypeEnum = (typeof NodeDTOTypeEnum)[keyof typeof NodeDTOTypeEnum];
export const NodeDTOBrokerTypeEnum = {
  Kafka: 'KAFKA',
  Jms: 'JMS',
  Rabbitmq: 'RABBITMQ',
  Undefined: 'UNDEFINED',
} as const;

export type NodeDTOBrokerTypeEnum = (typeof NodeDTOBrokerTypeEnum)[keyof typeof NodeDTOBrokerTypeEnum];
export const NodeDTOMethodTypeEnum = {
  Get: 'GET',
  Post: 'POST',
  Put: 'PUT',
  Head: 'HEAD',
  Delete: 'DELETE',
  Patch: 'PATCH',
  Options: 'OPTIONS',
  Connect: 'CONNECT',
  Trace: 'TRACE',
} as const;

export type NodeDTOMethodTypeEnum = (typeof NodeDTOMethodTypeEnum)[keyof typeof NodeDTOMethodTypeEnum];

/**
 *
 * @export
 * @interface SaveMarkdownPost201Response
 */
export interface SaveMarkdownPost201Response {
  /**
   * Message code
   * @type {number}
   * @memberof SaveMarkdownPost201Response
   */
  code?: number;
  /**
   * Response message
   * @type {string}
   * @memberof SaveMarkdownPost201Response
   */
  message?: string;
  /**
   * Indicates failure due to client error
   * @type {string}
   * @memberof SaveMarkdownPost201Response
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof SaveMarkdownPost201Response
   */
  filePath?: string;
}
/**
 *
 * @export
 * @interface SaveMarkdownPostRequest
 */
export interface SaveMarkdownPostRequest {
  /**
   *
   * @type {string}
   * @memberof SaveMarkdownPostRequest
   */
  markdown: string;
  /**
   * Relative path (e.g., \"markdown/readme_1.md\")
   * @type {string}
   * @memberof SaveMarkdownPostRequest
   */
  filePath: string;
}
/**
 * Object who saved info about service
 * @export
 * @interface ServiceInfo
 */
export interface ServiceInfo {
  /**
   *
   * @type {string}
   * @memberof ServiceInfo
   */
  specificationPath?: string;
  /**
   *
   * @type {string}
   * @memberof ServiceInfo
   */
  port?: string;
  /**
   *
   * @type {string}
   * @memberof ServiceInfo
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ServiceInfo
   */
  brokerAddress?: string;
}
/**
 *
 * @export
 * @interface UpdateServiceSpecificationPostRequest
 */
export interface UpdateServiceSpecificationPostRequest {
  /**
   * UUID of the service node to update
   * @type {string}
   * @memberof UpdateServiceSpecificationPostRequest
   */
  serviceNodeId: string;
  /**
   * New OpenAPI specification as a string
   * @type {string}
   * @memberof UpdateServiceSpecificationPostRequest
   */
  specification: string;
  /**
   *
   * @type {EventGraphDTO}
   * @memberof UpdateServiceSpecificationPostRequest
   */
  eventGraph: EventGraphDTO;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * git add documentation
     * @summary git add documentation
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addDocumentationPost: async (body: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('addDocumentationPost', 'body', body);
      const localVarPath = `/addDocumentation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts EventGraph and a list of specification files to add services. Returns the updated EventGraph and a list of errors if any.
     * @summary Add services to an existing EventGraph from specification files
     * @param {Array<File>} files
     * @param {EventGraphDTO} eventGraph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addServiceToGraphPost: async (
      files: Array<File>,
      eventGraph: EventGraphDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'files' is not null or undefined
      assertParamExists('addServiceToGraphPost', 'files', files);
      // verify required parameter 'eventGraph' is not null or undefined
      assertParamExists('addServiceToGraphPost', 'eventGraph', eventGraph);
      const localVarPath = `/addServiceToGraph`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      if (files) {
        files.forEach(element => {
          localVarFormParams.append('files', element as any);
        });
      }

      if (eventGraph !== undefined) {
        localVarFormParams.append('eventGraph', new Blob([JSON.stringify(eventGraph)], {type: 'application/json'}));
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts an EventGraph object and two node UUIDs (`from`, `to`).  Returns all found paths between these nodes as arrays of LinkDTOs and a list of unique tags used in the paths.
     * @summary Calculate all paths in the EventGraph
     * @param {CalculateAllPathsPostRequest} calculateAllPathsPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    calculateAllPathsPost: async (
      calculateAllPathsPostRequest: CalculateAllPathsPostRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'calculateAllPathsPostRequest' is not null or undefined
      assertParamExists('calculateAllPathsPost', 'calculateAllPathsPostRequest', calculateAllPathsPostRequest);
      const localVarPath = `/calculateAllPaths`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(
        calculateAllPathsPostRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return path where documentation was cloned
     * @summary Clone documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cloneDocumentationPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/cloneDocumentation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * commit documentation
     * @summary commit documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitDocumentationPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/commitDocumentation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return merge request url
     * @summary create MR documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMRDocumentationPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/createMRDocumentation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download DOCX specification by fileId
     * @param {string} fileId Identifier of the DOCX specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadDocxFileIdDocxGet: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('downloadDocxFileIdDocxGet', 'fileId', fileId);
      const localVarPath = `/download/docx/{fileId}.docx`.replace(`{${'fileId'}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download Markdown specification by fileId
     * @param {string} fileId Identifier of the Markdown specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadMarkdownFileIdMdGet: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('downloadMarkdownFileIdMdGet', 'fileId', fileId);
      const localVarPath = `/download/markdown/{fileId}.md`.replace(
        `{${'fileId'}}`,
        encodeURIComponent(String(fileId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download PDF specification by fileId
     * @param {string} fileId Identifier of the PDF specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadPdfFileIdPdfGet: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('downloadPdfFileIdPdfGet', 'fileId', fileId);
      const localVarPath = `/download/pdf/{fileId}.pdf`.replace(`{${'fileId'}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download JSON specification by fileId
     * @param {string} fileId Identifier of the JSON specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadSpecsFileIdJsonGet: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('downloadSpecsFileIdJsonGet', 'fileId', fileId);
      const localVarPath = `/download/specs/{fileId}.json`.replace(`{${'fileId'}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download YAML specification by fileId
     * @param {string} fileId Identifier of the YAML specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadSpecsFileIdYamlGet: async (fileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('downloadSpecsFileIdYamlGet', 'fileId', fileId);
      const localVarPath = `/download/specs/{fileId}.yaml`.replace(`{${'fileId'}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts an EventGraphDTO object and generates a single consolidated PDF (or DOCX) document containing both the documentation and specifications for all services in the graph. For each service, a Markdown-based section is created and converted to PDF, preserving any links between services. At the end of the PDF, the raw specifications for each service are appended, each prefixed with a heading \"Specification of service <service name>\".
     * @summary Generate PDF documentation from EventGraphDTO
     * @param {EventGraphDTO} eventGraphDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateAllServicePdfPost: async (
      eventGraphDTO: EventGraphDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventGraphDTO' is not null or undefined
      assertParamExists('generateAllServicePdfPost', 'eventGraphDTO', eventGraphDTO);
      const localVarPath = `/generateAllServicePdf`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(eventGraphDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts an EventGraphDTO, generates OpenAPI specifications for each service node Returns the generated link for download files as zip archive
     * @summary Generate service code from EventGraphDTO
     * @param {EventGraphDTO} eventGraphDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCodePost: async (
      eventGraphDTO: EventGraphDTO,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventGraphDTO' is not null or undefined
      assertParamExists('generateCodePost', 'eventGraphDTO', eventGraphDTO);
      const localVarPath = `/generateCode`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(eventGraphDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates DOCX documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.docx file.
     * @summary Generate DOCX documentation from EventGraphDTO
     * @param {EventGraphDTO} eventGraphDTO
     * @param {Array<string>} [serviceIds] Optional list of service UUIDs to generate documentation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateDocxPost: async (
      eventGraphDTO: EventGraphDTO,
      serviceIds?: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventGraphDTO' is not null or undefined
      assertParamExists('generateDocxPost', 'eventGraphDTO', eventGraphDTO);
      const localVarPath = `/generateDocx`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serviceIds) {
        localVarQueryParameter['serviceIds'] = serviceIds;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(eventGraphDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts a JSON schema as a string and generates an example JSON based on the schema.
     * @summary Generate a JSON example from a JSON schema
     * @param {GenerateJsonExamplePostRequest} generateJsonExamplePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateJsonExamplePost: async (
      generateJsonExamplePostRequest: GenerateJsonExamplePostRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'generateJsonExamplePostRequest' is not null or undefined
      assertParamExists('generateJsonExamplePost', 'generateJsonExamplePostRequest', generateJsonExamplePostRequest);
      const localVarPath = `/generateJsonExample`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(
        generateJsonExamplePostRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts a JSON input as a string and generates a JSON schema based on that input.
     * @summary Generate a JSON schema from JSON input
     * @param {GenerateJsonSchemaPostRequest} generateJsonSchemaPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateJsonSchemaPost: async (
      generateJsonSchemaPostRequest: GenerateJsonSchemaPostRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'generateJsonSchemaPostRequest' is not null or undefined
      assertParamExists('generateJsonSchemaPost', 'generateJsonSchemaPostRequest', generateJsonSchemaPostRequest);
      const localVarPath = `/generateJsonSchema`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(
        generateJsonSchemaPostRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates Markdown documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.md file.
     * @summary Generate Markdown documentation from EventGraphDTO
     * @param {EventGraphDTO} eventGraphDTO
     * @param {Array<string>} [serviceIds] Optional list of service UUIDs to generate documentation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMarkdownPost: async (
      eventGraphDTO: EventGraphDTO,
      serviceIds?: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventGraphDTO' is not null or undefined
      assertParamExists('generateMarkdownPost', 'eventGraphDTO', eventGraphDTO);
      const localVarPath = `/generateMarkdown`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serviceIds) {
        localVarQueryParameter['serviceIds'] = serviceIds;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(eventGraphDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates PDF documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.pdf file.
     * @summary Generate PDF documentation from EventGraphDTO
     * @param {EventGraphDTO} eventGraphDTO
     * @param {Array<string>} [serviceIds] Optional list of service UUIDs to generate documentation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generatePdfPost: async (
      eventGraphDTO: EventGraphDTO,
      serviceIds?: Array<string>,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventGraphDTO' is not null or undefined
      assertParamExists('generatePdfPost', 'eventGraphDTO', eventGraphDTO);
      const localVarPath = `/generatePdf`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (serviceIds) {
        localVarQueryParameter['serviceIds'] = serviceIds;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(eventGraphDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts an EventGraph object and validates whether it can generate an OpenAPI specification. Returns status \"OK\" and links to generated specification files on success, or status \"ERROR\" with an error message otherwise.
     * @summary Validate EventGraph and generate OpenAPI specification
     * @param {EventGraphDTO} eventGraphDTO
     * @param {GenerateSpecPostFormatEnum} [format] Format of the downloadable specification file (default is json)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateSpecPost: async (
      eventGraphDTO: EventGraphDTO,
      format?: GenerateSpecPostFormatEnum,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'eventGraphDTO' is not null or undefined
      assertParamExists('generateSpecPost', 'eventGraphDTO', eventGraphDTO);
      const localVarPath = `/generateSpec`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (format !== undefined) {
        localVarQueryParameter['format'] = format;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(eventGraphDTO, localVarRequestOptions, configuration);

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts a service node UUID and returns the OpenAPI specification as a string.
     * @summary Get specification for a service node
     * @param {GetServiceSpecificationPostRequest} getServiceSpecificationPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceSpecificationPost: async (
      getServiceSpecificationPostRequest: GetServiceSpecificationPostRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'getServiceSpecificationPostRequest' is not null or undefined
      assertParamExists(
        'getServiceSpecificationPost',
        'getServiceSpecificationPostRequest',
        getServiceSpecificationPostRequest
      );
      const localVarPath = `/getServiceSpecification`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(
        getServiceSpecificationPostRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Simple endpoint to check if the service is up and running.
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/health`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts Markdown content and a relative file path, then saves the content to a .md file on the server.
     * @summary Save Markdown text to a file
     * @param {string} authorization Git token, e.g. \&quot;Bearer ghp_xxx...\&quot;
     * @param {SaveMarkdownPostRequest} saveMarkdownPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveMarkdownPost: async (
      authorization: string,
      saveMarkdownPostRequest: SaveMarkdownPostRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'authorization' is not null or undefined
      assertParamExists('saveMarkdownPost', 'authorization', authorization);
      // verify required parameter 'saveMarkdownPostRequest' is not null or undefined
      assertParamExists('saveMarkdownPost', 'saveMarkdownPostRequest', saveMarkdownPostRequest);
      const localVarPath = `/saveMarkdown`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      if (authorization != null) {
        localVarHeaderParameter['Authorization'] = String(authorization);
      }
      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(
        saveMarkdownPostRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts a service node UUID and a new specification string. Updates the service in the EventGraph and returns the updated EventGraph.
     * @summary Update a service node with new specification
     * @param {UpdateServiceSpecificationPostRequest} updateServiceSpecificationPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateServiceSpecificationPost: async (
      updateServiceSpecificationPostRequest: UpdateServiceSpecificationPostRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'updateServiceSpecificationPostRequest' is not null or undefined
      assertParamExists(
        'updateServiceSpecificationPost',
        'updateServiceSpecificationPostRequest',
        updateServiceSpecificationPostRequest
      );
      const localVarPath = `/updateServiceSpecification`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateServiceSpecificationPostRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Accepts a list of files and returns an EventGraph object.
     * @summary Upload files and get EventGraph
     * @param {Array<File>} files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadPost: async (files: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'files' is not null or undefined
      assertParamExists('uploadPost', 'files', files);
      const localVarPath = `/upload`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

      if (files) {
        files.forEach(element => {
          localVarFormParams.append('files', element as any);
        });
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration);
  return {
    /**
     * git add documentation
     * @summary git add documentation
     * @param {string} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addDocumentationPost(
      body: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addDocumentationPost(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.addDocumentationPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts EventGraph and a list of specification files to add services. Returns the updated EventGraph and a list of errors if any.
     * @summary Add services to an existing EventGraph from specification files
     * @param {Array<File>} files
     * @param {EventGraphDTO} eventGraph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addServiceToGraphPost(
      files: Array<File>,
      eventGraph: EventGraphDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventGraphDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addServiceToGraphPost(files, eventGraph, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.addServiceToGraphPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts an EventGraph object and two node UUIDs (`from`, `to`).  Returns all found paths between these nodes as arrays of LinkDTOs and a list of unique tags used in the paths.
     * @summary Calculate all paths in the EventGraph
     * @param {CalculateAllPathsPostRequest} calculateAllPathsPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async calculateAllPathsPost(
      calculateAllPathsPostRequest: CalculateAllPathsPostRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalculateAllPathsPost200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.calculateAllPathsPost(
        calculateAllPathsPostRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.calculateAllPathsPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Return path where documentation was cloned
     * @summary Clone documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cloneDocumentationPost(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cloneDocumentationPost(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.cloneDocumentationPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * commit documentation
     * @summary commit documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async commitDocumentationPost(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.commitDocumentationPost(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.commitDocumentationPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Return merge request url
     * @summary create MR documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createMRDocumentationPost(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createMRDocumentationPost(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.createMRDocumentationPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Download DOCX specification by fileId
     * @param {string} fileId Identifier of the DOCX specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadDocxFileIdDocxGet(
      fileId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocxFileIdDocxGet(fileId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.downloadDocxFileIdDocxGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Download Markdown specification by fileId
     * @param {string} fileId Identifier of the Markdown specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadMarkdownFileIdMdGet(
      fileId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadMarkdownFileIdMdGet(fileId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.downloadMarkdownFileIdMdGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Download PDF specification by fileId
     * @param {string} fileId Identifier of the PDF specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadPdfFileIdPdfGet(
      fileId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadPdfFileIdPdfGet(fileId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.downloadPdfFileIdPdfGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Download JSON specification by fileId
     * @param {string} fileId Identifier of the JSON specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadSpecsFileIdJsonGet(
      fileId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSpecsFileIdJsonGet(fileId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.downloadSpecsFileIdJsonGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Download YAML specification by fileId
     * @param {string} fileId Identifier of the YAML specification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadSpecsFileIdYamlGet(
      fileId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSpecsFileIdYamlGet(fileId, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.downloadSpecsFileIdYamlGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts an EventGraphDTO object and generates a single consolidated PDF (or DOCX) document containing both the documentation and specifications for all services in the graph. For each service, a Markdown-based section is created and converted to PDF, preserving any links between services. At the end of the PDF, the raw specifications for each service are appended, each prefixed with a heading \"Specification of service <service name>\".
     * @summary Generate PDF documentation from EventGraphDTO
     * @param {EventGraphDTO} eventGraphDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateAllServicePdfPost(
      eventGraphDTO: EventGraphDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateAllServicePdfPost(eventGraphDTO, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.generateAllServicePdfPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts an EventGraphDTO, generates OpenAPI specifications for each service node Returns the generated link for download files as zip archive
     * @summary Generate service code from EventGraphDTO
     * @param {EventGraphDTO} eventGraphDTO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateCodePost(
      eventGraphDTO: EventGraphDTO,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateCodePost(eventGraphDTO, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.generateCodePost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates DOCX documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.docx file.
     * @summary Generate DOCX documentation from EventGraphDTO
     * @param {EventGraphDTO} eventGraphDTO
     * @param {Array<string>} [serviceIds] Optional list of service UUIDs to generate documentation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateDocxPost(
      eventGraphDTO: EventGraphDTO,
      serviceIds?: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateDocxPost200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateDocxPost(eventGraphDTO, serviceIds, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.generateDocxPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts a JSON schema as a string and generates an example JSON based on the schema.
     * @summary Generate a JSON example from a JSON schema
     * @param {GenerateJsonExamplePostRequest} generateJsonExamplePostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateJsonExamplePost(
      generateJsonExamplePostRequest: GenerateJsonExamplePostRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateJsonExamplePost200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateJsonExamplePost(
        generateJsonExamplePostRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.generateJsonExamplePost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts a JSON input as a string and generates a JSON schema based on that input.
     * @summary Generate a JSON schema from JSON input
     * @param {GenerateJsonSchemaPostRequest} generateJsonSchemaPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateJsonSchemaPost(
      generateJsonSchemaPostRequest: GenerateJsonSchemaPostRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateJsonSchemaPost200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateJsonSchemaPost(
        generateJsonSchemaPostRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.generateJsonSchemaPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates Markdown documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.md file.
     * @summary Generate Markdown documentation from EventGraphDTO
     * @param {EventGraphDTO} eventGraphDTO
     * @param {Array<string>} [serviceIds] Optional list of service UUIDs to generate documentation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateMarkdownPost(
      eventGraphDTO: EventGraphDTO,
      serviceIds?: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateMarkdownPost200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateMarkdownPost(
        eventGraphDTO,
        serviceIds,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.generateMarkdownPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates PDF documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.pdf file.
     * @summary Generate PDF documentation from EventGraphDTO
     * @param {EventGraphDTO} eventGraphDTO
     * @param {Array<string>} [serviceIds] Optional list of service UUIDs to generate documentation for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generatePdfPost(
      eventGraphDTO: EventGraphDTO,
      serviceIds?: Array<string>,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneratePdfPost200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generatePdfPost(eventGraphDTO, serviceIds, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.generatePdfPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts an EventGraph object and validates whether it can generate an OpenAPI specification. Returns status \"OK\" and links to generated specification files on success, or status \"ERROR\" with an error message otherwise.
     * @summary Validate EventGraph and generate OpenAPI specification
     * @param {EventGraphDTO} eventGraphDTO
     * @param {GenerateSpecPostFormatEnum} [format] Format of the downloadable specification file (default is json)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generateSpecPost(
      eventGraphDTO: EventGraphDTO,
      format?: GenerateSpecPostFormatEnum,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateSpecPost200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generateSpecPost(eventGraphDTO, format, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.generateSpecPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts a service node UUID and returns the OpenAPI specification as a string.
     * @summary Get specification for a service node
     * @param {GetServiceSpecificationPostRequest} getServiceSpecificationPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServiceSpecificationPost(
      getServiceSpecificationPostRequest: GetServiceSpecificationPostRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetServiceSpecificationPost200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceSpecificationPost(
        getServiceSpecificationPostRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.getServiceSpecificationPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Simple endpoint to check if the service is up and running.
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async healthGet(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.healthGet']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts Markdown content and a relative file path, then saves the content to a .md file on the server.
     * @summary Save Markdown text to a file
     * @param {string} authorization Git token, e.g. \&quot;Bearer ghp_xxx...\&quot;
     * @param {SaveMarkdownPostRequest} saveMarkdownPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async saveMarkdownPost(
      authorization: string,
      saveMarkdownPostRequest: SaveMarkdownPostRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaveMarkdownPost201Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.saveMarkdownPost(
        authorization,
        saveMarkdownPostRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.saveMarkdownPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts a service node UUID and a new specification string. Updates the service in the EventGraph and returns the updated EventGraph.
     * @summary Update a service node with new specification
     * @param {UpdateServiceSpecificationPostRequest} updateServiceSpecificationPostRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateServiceSpecificationPost(
      updateServiceSpecificationPostRequest: UpdateServiceSpecificationPostRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventGraphDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateServiceSpecificationPost(
        updateServiceSpecificationPostRequest,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.updateServiceSpecificationPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     * Accepts a list of files and returns an EventGraph object.
     * @summary Upload files and get EventGraph
     * @param {Array<File>} files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadPost(
      files: Array<File>,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventGraphDTO>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.uploadPost(files, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['DefaultApi.uploadPost']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = DefaultApiFp(configuration);
  return {
    /**
     * git add documentation
     * @summary git add documentation
     * @param {DefaultApiAddDocumentationPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addDocumentationPost(
      requestParameters: DefaultApiAddDocumentationPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp.addDocumentationPost(requestParameters.body, options).then(request => request(axios, basePath));
    },
    /**
     * Accepts EventGraph and a list of specification files to add services. Returns the updated EventGraph and a list of errors if any.
     * @summary Add services to an existing EventGraph from specification files
     * @param {DefaultApiAddServiceToGraphPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addServiceToGraphPost(
      requestParameters: DefaultApiAddServiceToGraphPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<EventGraphDTO> {
      return localVarFp
        .addServiceToGraphPost(requestParameters.files, requestParameters.eventGraph, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts an EventGraph object and two node UUIDs (`from`, `to`).  Returns all found paths between these nodes as arrays of LinkDTOs and a list of unique tags used in the paths.
     * @summary Calculate all paths in the EventGraph
     * @param {DefaultApiCalculateAllPathsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    calculateAllPathsPost(
      requestParameters: DefaultApiCalculateAllPathsPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<CalculateAllPathsPost200Response> {
      return localVarFp
        .calculateAllPathsPost(requestParameters.calculateAllPathsPostRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Return path where documentation was cloned
     * @summary Clone documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cloneDocumentationPost(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.cloneDocumentationPost(options).then(request => request(axios, basePath));
    },
    /**
     * commit documentation
     * @summary commit documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    commitDocumentationPost(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.commitDocumentationPost(options).then(request => request(axios, basePath));
    },
    /**
     * Return merge request url
     * @summary create MR documentation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createMRDocumentationPost(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.createMRDocumentationPost(options).then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Download DOCX specification by fileId
     * @param {DefaultApiDownloadDocxFileIdDocxGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadDocxFileIdDocxGet(
      requestParameters: DefaultApiDownloadDocxFileIdDocxGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .downloadDocxFileIdDocxGet(requestParameters.fileId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Download Markdown specification by fileId
     * @param {DefaultApiDownloadMarkdownFileIdMdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadMarkdownFileIdMdGet(
      requestParameters: DefaultApiDownloadMarkdownFileIdMdGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .downloadMarkdownFileIdMdGet(requestParameters.fileId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Download PDF specification by fileId
     * @param {DefaultApiDownloadPdfFileIdPdfGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadPdfFileIdPdfGet(
      requestParameters: DefaultApiDownloadPdfFileIdPdfGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .downloadPdfFileIdPdfGet(requestParameters.fileId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Download JSON specification by fileId
     * @param {DefaultApiDownloadSpecsFileIdJsonGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadSpecsFileIdJsonGet(
      requestParameters: DefaultApiDownloadSpecsFileIdJsonGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .downloadSpecsFileIdJsonGet(requestParameters.fileId, options)
        .then(request => request(axios, basePath));
    },
    /**
     *
     * @summary Download YAML specification by fileId
     * @param {DefaultApiDownloadSpecsFileIdYamlGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadSpecsFileIdYamlGet(
      requestParameters: DefaultApiDownloadSpecsFileIdYamlGetRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .downloadSpecsFileIdYamlGet(requestParameters.fileId, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts an EventGraphDTO object and generates a single consolidated PDF (or DOCX) document containing both the documentation and specifications for all services in the graph. For each service, a Markdown-based section is created and converted to PDF, preserving any links between services. At the end of the PDF, the raw specifications for each service are appended, each prefixed with a heading \"Specification of service <service name>\".
     * @summary Generate PDF documentation from EventGraphDTO
     * @param {DefaultApiGenerateAllServicePdfPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateAllServicePdfPost(
      requestParameters: DefaultApiGenerateAllServicePdfPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .generateAllServicePdfPost(requestParameters.eventGraphDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts an EventGraphDTO, generates OpenAPI specifications for each service node Returns the generated link for download files as zip archive
     * @summary Generate service code from EventGraphDTO
     * @param {DefaultApiGenerateCodePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateCodePost(
      requestParameters: DefaultApiGenerateCodePostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<File> {
      return localVarFp
        .generateCodePost(requestParameters.eventGraphDTO, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates DOCX documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.docx file.
     * @summary Generate DOCX documentation from EventGraphDTO
     * @param {DefaultApiGenerateDocxPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateDocxPost(
      requestParameters: DefaultApiGenerateDocxPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GenerateDocxPost200Response> {
      return localVarFp
        .generateDocxPost(requestParameters.eventGraphDTO, requestParameters.serviceIds, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts a JSON schema as a string and generates an example JSON based on the schema.
     * @summary Generate a JSON example from a JSON schema
     * @param {DefaultApiGenerateJsonExamplePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateJsonExamplePost(
      requestParameters: DefaultApiGenerateJsonExamplePostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GenerateJsonExamplePost200Response> {
      return localVarFp
        .generateJsonExamplePost(requestParameters.generateJsonExamplePostRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts a JSON input as a string and generates a JSON schema based on that input.
     * @summary Generate a JSON schema from JSON input
     * @param {DefaultApiGenerateJsonSchemaPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateJsonSchemaPost(
      requestParameters: DefaultApiGenerateJsonSchemaPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GenerateJsonSchemaPost200Response> {
      return localVarFp
        .generateJsonSchemaPost(requestParameters.generateJsonSchemaPostRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates Markdown documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.md file.
     * @summary Generate Markdown documentation from EventGraphDTO
     * @param {DefaultApiGenerateMarkdownPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateMarkdownPost(
      requestParameters: DefaultApiGenerateMarkdownPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GenerateMarkdownPost200Response> {
      return localVarFp
        .generateMarkdownPost(requestParameters.eventGraphDTO, requestParameters.serviceIds, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates PDF documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.pdf file.
     * @summary Generate PDF documentation from EventGraphDTO
     * @param {DefaultApiGeneratePdfPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generatePdfPost(
      requestParameters: DefaultApiGeneratePdfPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GeneratePdfPost200Response> {
      return localVarFp
        .generatePdfPost(requestParameters.eventGraphDTO, requestParameters.serviceIds, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts an EventGraph object and validates whether it can generate an OpenAPI specification. Returns status \"OK\" and links to generated specification files on success, or status \"ERROR\" with an error message otherwise.
     * @summary Validate EventGraph and generate OpenAPI specification
     * @param {DefaultApiGenerateSpecPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generateSpecPost(
      requestParameters: DefaultApiGenerateSpecPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GenerateSpecPost200Response> {
      return localVarFp
        .generateSpecPost(requestParameters.eventGraphDTO, requestParameters.format, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts a service node UUID and returns the OpenAPI specification as a string.
     * @summary Get specification for a service node
     * @param {DefaultApiGetServiceSpecificationPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServiceSpecificationPost(
      requestParameters: DefaultApiGetServiceSpecificationPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<GetServiceSpecificationPost200Response> {
      return localVarFp
        .getServiceSpecificationPost(requestParameters.getServiceSpecificationPostRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Simple endpoint to check if the service is up and running.
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    healthGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp.healthGet(options).then(request => request(axios, basePath));
    },
    /**
     * Accepts Markdown content and a relative file path, then saves the content to a .md file on the server.
     * @summary Save Markdown text to a file
     * @param {DefaultApiSaveMarkdownPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    saveMarkdownPost(
      requestParameters: DefaultApiSaveMarkdownPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<SaveMarkdownPost201Response> {
      return localVarFp
        .saveMarkdownPost(requestParameters.authorization, requestParameters.saveMarkdownPostRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts a service node UUID and a new specification string. Updates the service in the EventGraph and returns the updated EventGraph.
     * @summary Update a service node with new specification
     * @param {DefaultApiUpdateServiceSpecificationPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateServiceSpecificationPost(
      requestParameters: DefaultApiUpdateServiceSpecificationPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<EventGraphDTO> {
      return localVarFp
        .updateServiceSpecificationPost(requestParameters.updateServiceSpecificationPostRequest, options)
        .then(request => request(axios, basePath));
    },
    /**
     * Accepts a list of files and returns an EventGraph object.
     * @summary Upload files and get EventGraph
     * @param {DefaultApiUploadPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadPost(
      requestParameters: DefaultApiUploadPostRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<EventGraphDTO> {
      return localVarFp.uploadPost(requestParameters.files, options).then(request => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for addDocumentationPost operation in DefaultApi.
 * @export
 * @interface DefaultApiAddDocumentationPostRequest
 */
export interface DefaultApiAddDocumentationPostRequest {
  /**
   *
   * @type {string}
   * @memberof DefaultApiAddDocumentationPost
   */
  readonly body: string;
}

/**
 * Request parameters for addServiceToGraphPost operation in DefaultApi.
 * @export
 * @interface DefaultApiAddServiceToGraphPostRequest
 */
export interface DefaultApiAddServiceToGraphPostRequest {
  /**
   *
   * @type {Array<File>}
   * @memberof DefaultApiAddServiceToGraphPost
   */
  readonly files: Array<File>;

  /**
   *
   * @type {EventGraphDTO}
   * @memberof DefaultApiAddServiceToGraphPost
   */
  readonly eventGraph: EventGraphDTO;
}

/**
 * Request parameters for calculateAllPathsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiCalculateAllPathsPostRequest
 */
export interface DefaultApiCalculateAllPathsPostRequest {
  /**
   *
   * @type {CalculateAllPathsPostRequest}
   * @memberof DefaultApiCalculateAllPathsPost
   */
  readonly calculateAllPathsPostRequest: CalculateAllPathsPostRequest;
}

/**
 * Request parameters for downloadDocxFileIdDocxGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadDocxFileIdDocxGetRequest
 */
export interface DefaultApiDownloadDocxFileIdDocxGetRequest {
  /**
   * Identifier of the DOCX specification
   * @type {string}
   * @memberof DefaultApiDownloadDocxFileIdDocxGet
   */
  readonly fileId: string;
}

/**
 * Request parameters for downloadMarkdownFileIdMdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadMarkdownFileIdMdGetRequest
 */
export interface DefaultApiDownloadMarkdownFileIdMdGetRequest {
  /**
   * Identifier of the Markdown specification
   * @type {string}
   * @memberof DefaultApiDownloadMarkdownFileIdMdGet
   */
  readonly fileId: string;
}

/**
 * Request parameters for downloadPdfFileIdPdfGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadPdfFileIdPdfGetRequest
 */
export interface DefaultApiDownloadPdfFileIdPdfGetRequest {
  /**
   * Identifier of the PDF specification
   * @type {string}
   * @memberof DefaultApiDownloadPdfFileIdPdfGet
   */
  readonly fileId: string;
}

/**
 * Request parameters for downloadSpecsFileIdJsonGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadSpecsFileIdJsonGetRequest
 */
export interface DefaultApiDownloadSpecsFileIdJsonGetRequest {
  /**
   * Identifier of the JSON specification
   * @type {string}
   * @memberof DefaultApiDownloadSpecsFileIdJsonGet
   */
  readonly fileId: string;
}

/**
 * Request parameters for downloadSpecsFileIdYamlGet operation in DefaultApi.
 * @export
 * @interface DefaultApiDownloadSpecsFileIdYamlGetRequest
 */
export interface DefaultApiDownloadSpecsFileIdYamlGetRequest {
  /**
   * Identifier of the YAML specification
   * @type {string}
   * @memberof DefaultApiDownloadSpecsFileIdYamlGet
   */
  readonly fileId: string;
}

/**
 * Request parameters for generateAllServicePdfPost operation in DefaultApi.
 * @export
 * @interface DefaultApiGenerateAllServicePdfPostRequest
 */
export interface DefaultApiGenerateAllServicePdfPostRequest {
  /**
   *
   * @type {EventGraphDTO}
   * @memberof DefaultApiGenerateAllServicePdfPost
   */
  readonly eventGraphDTO: EventGraphDTO;
}

/**
 * Request parameters for generateCodePost operation in DefaultApi.
 * @export
 * @interface DefaultApiGenerateCodePostRequest
 */
export interface DefaultApiGenerateCodePostRequest {
  /**
   *
   * @type {EventGraphDTO}
   * @memberof DefaultApiGenerateCodePost
   */
  readonly eventGraphDTO: EventGraphDTO;
}

/**
 * Request parameters for generateDocxPost operation in DefaultApi.
 * @export
 * @interface DefaultApiGenerateDocxPostRequest
 */
export interface DefaultApiGenerateDocxPostRequest {
  /**
   *
   * @type {EventGraphDTO}
   * @memberof DefaultApiGenerateDocxPost
   */
  readonly eventGraphDTO: EventGraphDTO;

  /**
   * Optional list of service UUIDs to generate documentation for.
   * @type {Array<string>}
   * @memberof DefaultApiGenerateDocxPost
   */
  readonly serviceIds?: Array<string>;
}

/**
 * Request parameters for generateJsonExamplePost operation in DefaultApi.
 * @export
 * @interface DefaultApiGenerateJsonExamplePostRequest
 */
export interface DefaultApiGenerateJsonExamplePostRequest {
  /**
   *
   * @type {GenerateJsonExamplePostRequest}
   * @memberof DefaultApiGenerateJsonExamplePost
   */
  readonly generateJsonExamplePostRequest: GenerateJsonExamplePostRequest;
}

/**
 * Request parameters for generateJsonSchemaPost operation in DefaultApi.
 * @export
 * @interface DefaultApiGenerateJsonSchemaPostRequest
 */
export interface DefaultApiGenerateJsonSchemaPostRequest {
  /**
   *
   * @type {GenerateJsonSchemaPostRequest}
   * @memberof DefaultApiGenerateJsonSchemaPost
   */
  readonly generateJsonSchemaPostRequest: GenerateJsonSchemaPostRequest;
}

/**
 * Request parameters for generateMarkdownPost operation in DefaultApi.
 * @export
 * @interface DefaultApiGenerateMarkdownPostRequest
 */
export interface DefaultApiGenerateMarkdownPostRequest {
  /**
   *
   * @type {EventGraphDTO}
   * @memberof DefaultApiGenerateMarkdownPost
   */
  readonly eventGraphDTO: EventGraphDTO;

  /**
   * Optional list of service UUIDs to generate documentation for.
   * @type {Array<string>}
   * @memberof DefaultApiGenerateMarkdownPost
   */
  readonly serviceIds?: Array<string>;
}

/**
 * Request parameters for generatePdfPost operation in DefaultApi.
 * @export
 * @interface DefaultApiGeneratePdfPostRequest
 */
export interface DefaultApiGeneratePdfPostRequest {
  /**
   *
   * @type {EventGraphDTO}
   * @memberof DefaultApiGeneratePdfPost
   */
  readonly eventGraphDTO: EventGraphDTO;

  /**
   * Optional list of service UUIDs to generate documentation for.
   * @type {Array<string>}
   * @memberof DefaultApiGeneratePdfPost
   */
  readonly serviceIds?: Array<string>;
}

/**
 * Request parameters for generateSpecPost operation in DefaultApi.
 * @export
 * @interface DefaultApiGenerateSpecPostRequest
 */
export interface DefaultApiGenerateSpecPostRequest {
  /**
   *
   * @type {EventGraphDTO}
   * @memberof DefaultApiGenerateSpecPost
   */
  readonly eventGraphDTO: EventGraphDTO;

  /**
   * Format of the downloadable specification file (default is json)
   * @type {'json' | 'yaml'}
   * @memberof DefaultApiGenerateSpecPost
   */
  readonly format?: GenerateSpecPostFormatEnum;
}

/**
 * Request parameters for getServiceSpecificationPost operation in DefaultApi.
 * @export
 * @interface DefaultApiGetServiceSpecificationPostRequest
 */
export interface DefaultApiGetServiceSpecificationPostRequest {
  /**
   *
   * @type {GetServiceSpecificationPostRequest}
   * @memberof DefaultApiGetServiceSpecificationPost
   */
  readonly getServiceSpecificationPostRequest: GetServiceSpecificationPostRequest;
}

/**
 * Request parameters for saveMarkdownPost operation in DefaultApi.
 * @export
 * @interface DefaultApiSaveMarkdownPostRequest
 */
export interface DefaultApiSaveMarkdownPostRequest {
  /**
   * Git token, e.g. \&quot;Bearer ghp_xxx...\&quot;
   * @type {string}
   * @memberof DefaultApiSaveMarkdownPost
   */
  readonly authorization: string;

  /**
   *
   * @type {SaveMarkdownPostRequest}
   * @memberof DefaultApiSaveMarkdownPost
   */
  readonly saveMarkdownPostRequest: SaveMarkdownPostRequest;
}

/**
 * Request parameters for updateServiceSpecificationPost operation in DefaultApi.
 * @export
 * @interface DefaultApiUpdateServiceSpecificationPostRequest
 */
export interface DefaultApiUpdateServiceSpecificationPostRequest {
  /**
   *
   * @type {UpdateServiceSpecificationPostRequest}
   * @memberof DefaultApiUpdateServiceSpecificationPost
   */
  readonly updateServiceSpecificationPostRequest: UpdateServiceSpecificationPostRequest;
}

/**
 * Request parameters for uploadPost operation in DefaultApi.
 * @export
 * @interface DefaultApiUploadPostRequest
 */
export interface DefaultApiUploadPostRequest {
  /**
   *
   * @type {Array<File>}
   * @memberof DefaultApiUploadPost
   */
  readonly files: Array<File>;
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * git add documentation
   * @summary git add documentation
   * @param {DefaultApiAddDocumentationPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public addDocumentationPost(
    requestParameters: DefaultApiAddDocumentationPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .addDocumentationPost(requestParameters.body, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts EventGraph and a list of specification files to add services. Returns the updated EventGraph and a list of errors if any.
   * @summary Add services to an existing EventGraph from specification files
   * @param {DefaultApiAddServiceToGraphPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public addServiceToGraphPost(
    requestParameters: DefaultApiAddServiceToGraphPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .addServiceToGraphPost(requestParameters.files, requestParameters.eventGraph, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts an EventGraph object and two node UUIDs (`from`, `to`).  Returns all found paths between these nodes as arrays of LinkDTOs and a list of unique tags used in the paths.
   * @summary Calculate all paths in the EventGraph
   * @param {DefaultApiCalculateAllPathsPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public calculateAllPathsPost(
    requestParameters: DefaultApiCalculateAllPathsPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .calculateAllPathsPost(requestParameters.calculateAllPathsPostRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Return path where documentation was cloned
   * @summary Clone documentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public cloneDocumentationPost(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .cloneDocumentationPost(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * commit documentation
   * @summary commit documentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public commitDocumentationPost(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .commitDocumentationPost(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Return merge request url
   * @summary create MR documentation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createMRDocumentationPost(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .createMRDocumentationPost(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download DOCX specification by fileId
   * @param {DefaultApiDownloadDocxFileIdDocxGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadDocxFileIdDocxGet(
    requestParameters: DefaultApiDownloadDocxFileIdDocxGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .downloadDocxFileIdDocxGet(requestParameters.fileId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download Markdown specification by fileId
   * @param {DefaultApiDownloadMarkdownFileIdMdGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadMarkdownFileIdMdGet(
    requestParameters: DefaultApiDownloadMarkdownFileIdMdGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .downloadMarkdownFileIdMdGet(requestParameters.fileId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download PDF specification by fileId
   * @param {DefaultApiDownloadPdfFileIdPdfGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadPdfFileIdPdfGet(
    requestParameters: DefaultApiDownloadPdfFileIdPdfGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .downloadPdfFileIdPdfGet(requestParameters.fileId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download JSON specification by fileId
   * @param {DefaultApiDownloadSpecsFileIdJsonGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadSpecsFileIdJsonGet(
    requestParameters: DefaultApiDownloadSpecsFileIdJsonGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .downloadSpecsFileIdJsonGet(requestParameters.fileId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download YAML specification by fileId
   * @param {DefaultApiDownloadSpecsFileIdYamlGetRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public downloadSpecsFileIdYamlGet(
    requestParameters: DefaultApiDownloadSpecsFileIdYamlGetRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .downloadSpecsFileIdYamlGet(requestParameters.fileId, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts an EventGraphDTO object and generates a single consolidated PDF (or DOCX) document containing both the documentation and specifications for all services in the graph. For each service, a Markdown-based section is created and converted to PDF, preserving any links between services. At the end of the PDF, the raw specifications for each service are appended, each prefixed with a heading \"Specification of service <service name>\".
   * @summary Generate PDF documentation from EventGraphDTO
   * @param {DefaultApiGenerateAllServicePdfPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public generateAllServicePdfPost(
    requestParameters: DefaultApiGenerateAllServicePdfPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .generateAllServicePdfPost(requestParameters.eventGraphDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts an EventGraphDTO, generates OpenAPI specifications for each service node Returns the generated link for download files as zip archive
   * @summary Generate service code from EventGraphDTO
   * @param {DefaultApiGenerateCodePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public generateCodePost(requestParameters: DefaultApiGenerateCodePostRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .generateCodePost(requestParameters.eventGraphDTO, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates DOCX documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.docx file.
   * @summary Generate DOCX documentation from EventGraphDTO
   * @param {DefaultApiGenerateDocxPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public generateDocxPost(requestParameters: DefaultApiGenerateDocxPostRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .generateDocxPost(requestParameters.eventGraphDTO, requestParameters.serviceIds, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts a JSON schema as a string and generates an example JSON based on the schema.
   * @summary Generate a JSON example from a JSON schema
   * @param {DefaultApiGenerateJsonExamplePostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public generateJsonExamplePost(
    requestParameters: DefaultApiGenerateJsonExamplePostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .generateJsonExamplePost(requestParameters.generateJsonExamplePostRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts a JSON input as a string and generates a JSON schema based on that input.
   * @summary Generate a JSON schema from JSON input
   * @param {DefaultApiGenerateJsonSchemaPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public generateJsonSchemaPost(
    requestParameters: DefaultApiGenerateJsonSchemaPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .generateJsonSchemaPost(requestParameters.generateJsonSchemaPostRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates Markdown documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.md file.
   * @summary Generate Markdown documentation from EventGraphDTO
   * @param {DefaultApiGenerateMarkdownPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public generateMarkdownPost(
    requestParameters: DefaultApiGenerateMarkdownPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .generateMarkdownPost(requestParameters.eventGraphDTO, requestParameters.serviceIds, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts an EventGraphDTO object and an optional list of service UUIDs. Generates PDF documentation for the selected services and their interactions, or for the entire graph if no IDs are specified. Returns a download link to the generated README.pdf file.
   * @summary Generate PDF documentation from EventGraphDTO
   * @param {DefaultApiGeneratePdfPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public generatePdfPost(requestParameters: DefaultApiGeneratePdfPostRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .generatePdfPost(requestParameters.eventGraphDTO, requestParameters.serviceIds, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts an EventGraph object and validates whether it can generate an OpenAPI specification. Returns status \"OK\" and links to generated specification files on success, or status \"ERROR\" with an error message otherwise.
   * @summary Validate EventGraph and generate OpenAPI specification
   * @param {DefaultApiGenerateSpecPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public generateSpecPost(requestParameters: DefaultApiGenerateSpecPostRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .generateSpecPost(requestParameters.eventGraphDTO, requestParameters.format, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts a service node UUID and returns the OpenAPI specification as a string.
   * @summary Get specification for a service node
   * @param {DefaultApiGetServiceSpecificationPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getServiceSpecificationPost(
    requestParameters: DefaultApiGetServiceSpecificationPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .getServiceSpecificationPost(requestParameters.getServiceSpecificationPostRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Simple endpoint to check if the service is up and running.
   * @summary Health check endpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public healthGet(options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .healthGet(options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts Markdown content and a relative file path, then saves the content to a .md file on the server.
   * @summary Save Markdown text to a file
   * @param {DefaultApiSaveMarkdownPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public saveMarkdownPost(requestParameters: DefaultApiSaveMarkdownPostRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .saveMarkdownPost(requestParameters.authorization, requestParameters.saveMarkdownPostRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts a service node UUID and a new specification string. Updates the service in the EventGraph and returns the updated EventGraph.
   * @summary Update a service node with new specification
   * @param {DefaultApiUpdateServiceSpecificationPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateServiceSpecificationPost(
    requestParameters: DefaultApiUpdateServiceSpecificationPostRequest,
    options?: RawAxiosRequestConfig
  ) {
    return DefaultApiFp(this.configuration)
      .updateServiceSpecificationPost(requestParameters.updateServiceSpecificationPostRequest, options)
      .then(request => request(this.axios, this.basePath));
  }

  /**
   * Accepts a list of files and returns an EventGraph object.
   * @summary Upload files and get EventGraph
   * @param {DefaultApiUploadPostRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public uploadPost(requestParameters: DefaultApiUploadPostRequest, options?: RawAxiosRequestConfig) {
    return DefaultApiFp(this.configuration)
      .uploadPost(requestParameters.files, options)
      .then(request => request(this.axios, this.basePath));
  }
}

/**
 * @export
 */
export const GenerateSpecPostFormatEnum = {
  Json: 'json',
  Yaml: 'yaml',
} as const;
export type GenerateSpecPostFormatEnum = (typeof GenerateSpecPostFormatEnum)[keyof typeof GenerateSpecPostFormatEnum];
